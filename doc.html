    <section class="suite">
      <h1>Actor</h1>
      <dl>
        <dt>should throw if no model is provided</dt>
        <dd><pre><code>assert.throws(function() {
	new Actor({});
});</code></pre></dd>
        <section class="suite">
          <h1>#nextTimeOfInterest</h1>
          <dl>
            <dt>should return the time before the next time of interest</dt>
            <dd><pre><code>assert.strictEqual(actor.nextTimeOfInterest(time), 0);
assert.strictEqual(actor.nextTimeOfInterest(time - 3), 3);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#action</h1>
          <dl>
            <dt>should register auto attack damage when auto attacking</dt>
            <dd><pre><code>actor.on(actor.events.autoattack, function(damage, critical, _time) {
				assert.strictEqual(_time, time);
				assert.strictEqual(damage.toFixed(2), &quot;158.75&quot;);
				assert.strictEqual(critical.toFixed(2), &quot;0.12&quot;);
				registered = true;
			});
			actor.action(time, target); // Auto Attack
			assert(registered);</code></pre></dd>
            <dt>should update actor.nextAutoAttack according to stats</dt>
            <dd><pre><code>actor.action(time, target); // Auto Attack
			assert.strictEqual(actor.nextAutoAttack, actor.getStats().getAutoAttackDelay() + time);</code></pre></dd>
            <dt>should apply skill effects</dt>
            <dd><pre><code>actor.nextAutoAttack += 10; // bypassing auto attack
			SteelPeak.nextAvailable = time + SteelPeak.recast; // bypassing SteelPeak
			actor.action(time, target); // Demolish (onGCD)
			actor.action(actor.nextTimeOfInterest(), target); // Demolish (onGCD)
			actor.action(actor.nextTimeOfInterest(), target); // Demolish (onGCD)
			target.action(target.nextTimeOfInterest(), target); // Demolish (onGCD)
			assert.strictEqual(actor.findAura(&quot;GreasedLigthning&quot;, actor).name, &quot;GreasedLigthning&quot;);
			assert.strictEqual(actor.findAura(&quot;OpoOpoForm&quot;, actor).name, &quot;OpoOpoForm&quot;);
			assert.strictEqual(target.findAura(&quot;DemolishDOT&quot;, actor).name, &quot;DemolishDOT&quot;);</code></pre></dd>
            <dt>should register skill damage and update actor.nextAction and actor.nextOffGCD when using onGCD skills in Action window</dt>
            <dd><pre><code>actor.on(actor.events.skill, function(damage, critical, name, _time) {
	assert.strictEqual(name, &quot;Demolish&quot;);
	registered = true;
});
actor.nextAutoAttack += 1; // bypassing auto attack
SteelPeak.nextAvailable = time + SteelPeak.recast; // bypassing SteelPeak
actor.action(time, target); // Demolish (onGCD)
assert.strictEqual(actor.nextAction, time + GCD);
assert.strictEqual(actor.nextOffGCD, time + GCD / 2);
assert(registered);</code></pre></dd>
            <dt>should register skill damage and update actor.nextAction and actor.nextOffGCD when using offGCD skills in Action window</dt>
            <dd><pre><code>actor.on(actor.events.skill, function(damage, critical, name, _time) {
				assert.strictEqual(name, &quot;SteelPeak&quot;);
				registered = true;
			});
			actor.nextAutoAttack += 1; // bypassing auto attack
			actor.action(time, target); // SteelPeak (offGCD)
			assert.strictEqual(actor.nextAction, time + GCD / 2);
			assert.strictEqual(actor.nextOffGCD, time + GCD);
			assert(registered);</code></pre></dd>
            <dt>should register skill damage and update actor.nextAction and actor.nextOffGCD when using offGCD skills in OffGCD window</dt>
            <dd><pre><code>actor.on(actor.events.skill, function(damage, critical, name, _time) {
				assert.strictEqual(name, &quot;SteelPeak&quot;);
				registered = true;
			});
			actor.nextAction = time + GCD;
			actor.nextOffGCD = time + GCD / 2;
			time = actor.nextOffGCD;
			actor.nextAutoAttack += 1; // bypassing auto attack
			actor.action(time, target); // SteelPeak (offGCD)
			assert.strictEqual(actor.nextAction, time + GCD / 2);
			assert.strictEqual(actor.nextOffGCD, time + GCD);
			assert(registered);</code></pre></dd>
            <dt>should not register skill damage and update actor.nextAction and actor.nextOffGCD when using onGCD skills in OffGCD window</dt>
            <dd><pre><code>actor.on(actor.events.skill, function(damage, critical, name, _time) {
				assert.strictEqual(name, &quot;Demolish&quot;);
				registered = true;
			});
			actor.nextAction = time + GCD;
			actor.nextOffGCD = time + GCD / 2;
			time = actor.nextOffGCD;
			actor.nextAutoAttack += 1; // bypassing auto attack
			SteelPeak.nextAvailable = time + SteelPeak.recast; // bypassing SteelPeak
			actor.action(time, target); // Demolish (onGCD)
			assert.strictEqual(actor.nextAction, time + GCD / 2);
			assert.strictEqual(actor.nextOffGCD, time + GCD);
			assert(!registered);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#preTick</h1>
          <dl>
            <dt>should remove expired auras from the actor</dt>
            <dd><pre><code>assert.strictEqual(actor.activeAuras.length, 0);
			actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
			actor.applyAuraImmediate(actor.model.auras.TwinSnakes, actor, time);
			assert.strictEqual(actor.activeAuras.length, 2);
			actor.preTick(time+13); // GreasedLigthning expired
			assert.strictEqual(actor.activeAuras.length, 1);
			actor.preTick(time+16); // TwinSnakes expired
			assert.strictEqual(actor.activeAuras.length, 0);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#tick</h1>
          <dl>
            <dt>should register DoTs damage</dt>
            <dd><pre><code>var registered = false;
			actor.on(actor.events.auraTick, function(damage, critical, name, _time) {
				assert.strictEqual(_time, time);
				assert.strictEqual(name, &quot;DemolishDOT&quot;);
				assert.strictEqual(damage.toFixed(2), &quot;74.12&quot;);
				assert.strictEqual(critical.toFixed(2), &quot;0.12&quot;);
				registered = true;
			});
			actor.applyAuraImmediate(actor.model.auras.DemolishDOT, actor, time);
			actor.tick(time);
			assert(registered);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#prepareForBattle</h1>
          <dl>
            <dt>should do nothing on inactive actor</dt>
            <dd><pre><code>var target = new Actor({
		model: &quot;Monk&quot;,
		name: &quot;Target&quot;,
		inactive: true,
	});
target.prepareForBattle(time);
assert.strictEqual(actor.findAura(&quot;FistOfFire&quot;, actor), false);</code></pre></dd>
            <dt>should apply auras according to model</dt>
            <dd><pre><code>actor.prepareForBattle(time);
assert.strictEqual(actor.findAura(&quot;FistOfFire&quot;, actor).name, &quot;FistOfFire&quot;);</code></pre></dd>
            <dt>should update actor.next*</dt>
            <dd><pre><code>actor.prepareForBattle(time);
assert.strictEqual(actor.nextAction, time);
assert.strictEqual(actor.nextAutoAttack, time);
assert.strictEqual(actor.nextOffGCD, time + actor.getStats().getGCD() / 2);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#applyAuraImmediate</h1>
          <dl>
            <dt>should register new aura</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(actor.activeAuras[0].name, &quot;GreasedLigthning&quot;);
assert.strictEqual(actor.activeAuras[0].owner, actor);</code></pre></dd>
            <dt>should refresh aura</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(actor.activeAuras[0].name, &quot;GreasedLigthning&quot;);
assert.strictEqual(actor.activeAuras[0].count, 2);</code></pre></dd>
            <dt>should not register new aura if the aura cancels itself</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.PerfectBalance, actor, time);
actor.applyAuraImmediate(actor.model.auras.RaptorForm, actor, time);
assert.strictEqual(actor.findAura(&quot;PerfectBalance&quot;, actor).name, &quot;PerfectBalance&quot;);
assert.strictEqual(actor.findAura(&quot;RaptorForm&quot;, actor), false);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#applyAura</h1>
          <dl>
          </dl>
        </section>
        <section class="suite">
          <h1>#findAura</h1>
          <dl>
            <dt>should return false if the aura is not present</dt>
            <dd><pre><code>assert.strictEqual(actor.findAura(&quot;GreasedLigthning&quot;, actor), false);</code></pre></dd>
            <dt>should return the aura if present</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(actor.findAura(&quot;GreasedLigthning&quot;, actor).name, &quot;GreasedLigthning&quot;);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#removeAura</h1>
          <dl>
            <dt>should remove the provided aura</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.InternalRelease, actor, time);
assert.strictEqual(actor.activeAuras.length, 1);
actor.removeAura(actor.findAura(&quot;InternalRelease&quot;, actor));
assert.strictEqual(actor.activeAuras.length, 0);</code></pre></dd>
            <dt>should return silently if the provided aura does not exists</dt>
            <dd><pre><code>assert.strictEqual(actor.activeAuras.length, 0);
assert.doesNotThrow(function() {
	actor.removeAura();
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getStats</h1>
          <dl>
            <dt>should return the actor stats buffed with auras</dt>
            <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.InternalRelease, actor, time);
assert.strictEqual(actor.getStats().criticalHitChance, 0.3);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Aura</h1>
      <dl>
        <section class="suite">
          <h1>.createAura</h1>
          <dl>
            <section class="suite">
              <h1>new .createAura</h1>
              <dl>
                <dt>should create an Aura constructor</dt>
                <dd><pre><code>assert.strictEqual(Aura.prototype.isPrototypeOf(new partyBonus), true);</code></pre></dd>
                <dt>should setup the aura with the provided configuration object</dt>
                <dd><pre><code>var pb = new partyBonus({
		time: time,
	}),
	gl = new greasedLigthning({
		time: time,
	}),
	dml = new Demolish({
		stats: stats,
		time: time,
	});
assert.strictEqual(pb.expireTime, Infinity);
assert.strictEqual(gl.expireTime, time+gl.duration);
assert.strictEqual(dml.tickDamage.toFixed(2), &quot;74.12&quot;);
assert.strictEqual(dml.tickCriticalRate.toFixed(2), &quot;0.12&quot;);
assert.strictEqual(gl.count, 1);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#refresh</h1>
              <dl>
                <dt>should refresh the aura with the provided configuration object</dt>
                <dd><pre><code>var gl = new greasedLigthning({
		time: time,
	});
time = 20;
gl.refresh({
	time:time
});
assert.strictEqual(gl.expireTime, time+12);
assert.strictEqual(gl.count, 2);
gl.refresh({
	time:time
});
assert.strictEqual(gl.count, 3);

gl.refresh({
	time:time
});
assert.strictEqual(gl.count, 3);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#onApply</h1>
              <dl>
                <dt>should execute when the aura is applied on the actor</dt>
                <dd><pre><code>actor.applyAuraImmediate(actor.model.auras.RaptorForm, actor, 0);
				assert.strictEqual(actor.activeAuras.length, 1);
				assert.strictEqual(actor.findAura(&quot;RaptorForm&quot;, actor), actor.activeAuras[0]);
				actor.applyAuraImmediate(actor.model.auras.CoeurlForm, actor, 0);
				assert.strictEqual(actor.activeAuras.length, 1);
				assert.strictEqual(actor.findAura(&quot;CoeurlForm&quot;, actor), actor.activeAuras[0]);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Rotation</h1>
      <dl>
        <section class="suite">
          <h1>#run</h1>
          <dl>
            <dt>should return undefined when the rotation does not return</dt>
            <dd><pre><code>var rotation = getRotation(&quot;empty&quot;);
assert.strictEqual(rotation.run(), void(0));</code></pre></dd>
            <dt>should return the skillname provided by the rotation file</dt>
            <dd><pre><code>var rotation = getRotation(&quot;skillname&quot;);
assert.strictEqual(rotation.run(), &quot;skillname&quot;);</code></pre></dd>
            <dt>should throw an exception if the rotation fail</dt>
            <dd><pre><code>var rotation = getRotation(&quot;throw&quot;);
assert.throws(function() {
	rotation.run();
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#AuraCount</h1>
          <dl>
            <dt>should return 0 if the searched aura does not validate the provided condition (name and source)</dt>
            <dd><pre><code>var rotation = getRotation(&quot;bad.AuraCount&quot;);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 0);</code></pre></dd>
            <dt>should return the stack count of the searched aura</dt>
            <dd><pre><code>var rotation = getRotation(&quot;good.AuraCount&quot;);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 1);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 2);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 3);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 3);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#IsReady</h1>
          <dl>
            <dt>should return true if the searched skill can be casted</dt>
            <dd><pre><code>var rotation = getRotation(&quot;IsReady&quot;);
assert.strictEqual(rotation.run(actor, target, time), true);
actor.model.skills.InternalRelease._onUse(time, actor, target);
assert.strictEqual(rotation.run(actor, target, time + actor.model.skills.InternalRelease.recast + 1), true);</code></pre></dd>
            <dt>should return false if the searched skill can't be casted</dt>
            <dd><pre><code>var rotation = getRotation(&quot;IsReady&quot;);
actor.model.skills.InternalRelease._onUse(time, actor, target);
assert.strictEqual(rotation.run(actor, target, time), false);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#IsOffGCD</h1>
          <dl>
            <dt>should return true if the actor is on a off GCD state</dt>
            <dd><pre><code>var rotation = getRotation(&quot;IsOffGCD&quot;);
actor.prepareForBattle(time);
assert.strictEqual(rotation.run(actor, target, actor.nextAction), false);
actor.nextAction = actor.nextAutoAttack = actor.nextOffGCD + 1;
assert.strictEqual(rotation.run(actor, target, actor.nextOffGCD), true);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#AuraTimeRemaining</h1>
          <dl>
            <dt>should return 0 if the searched aura does not validate the provided condition (name and source)</dt>
            <dd><pre><code>var rotation = getRotation(&quot;AuraTimeRemaining&quot;);
assert.strictEqual(rotation.run(actor, target, time), 0);</code></pre></dd>
            <dt>should return the time remaining of the searched aura</dt>
            <dd><pre><code>var rotation = getRotation(&quot;AuraTimeRemaining&quot;);
actor.applyAuraImmediate(actor.model.auras.GreasedLigthning, actor, time);
assert.strictEqual(rotation.run(actor, target, time), 12);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Scheduled2</h1>
      <dl>
        <section class="suite">
          <h1>#register</h1>
          <dl>
            <dt>should add item</dt>
            <dd><pre><code>scheduled.register(&quot;dummy1&quot;, dummy1, 3);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].fun, dummy1);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].time, 3 + scheduled.time);</code></pre></dd>
            <dt>should add current @time to item time</dt>
            <dd><pre><code>scheduled.time = 2;
scheduled.register(&quot;dummy1&quot;, dummy1, 3);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].time, 3 + scheduled.time);</code></pre></dd>
            <dt>should replace items with same name if the provided item is scheduled  earlier</dt>
            <dd><pre><code>scheduled.register(&quot;dummy1&quot;, dummy1, 3);
scheduled.register(&quot;dummy1&quot;, dummy2, 2);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].fun, dummy2);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].time, 2 + scheduled.time);</code></pre></dd>
            <dt>should not replace items with same name if the provided item is scheduled later</dt>
            <dd><pre><code>scheduled.register(&quot;dummy1&quot;, dummy1, 2);
scheduled.register(&quot;dummy1&quot;, dummy2, 3);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].fun, dummy1);
assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;].time, 2 + scheduled.time);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#next</h1>
          <dl>
            <dt>should return the most recent item</dt>
            <dd><pre><code>assert.strictEqual(next, dummy1);</code></pre></dd>
            <dt>should remove the most recent item</dt>
            <dd><pre><code>assert.strictEqual(scheduled.listeners[&quot;dummy1&quot;], void(0));</code></pre></dd>
            <dt>should set @time with the most recent item time</dt>
            <dd><pre><code>assert.strictEqual(scheduled.time, conf.time + 1);</code></pre></dd>
            <dt>should return false if @maxTime &gt;= @time</dt>
            <dd><pre><code>scheduled.maxTime = 0;
assert.strictEqual(scheduled.next(), false);</code></pre></dd>
            <dt>should return false if empty</dt>
            <dd><pre><code>scheduled.next(); // dummy2
scheduled.next(); // dummy3
assert.strictEqual(scheduled.next(), false);</code></pre></dd>
            <dt>should return a function with the correct 'this' pointer</dt>
            <dd><pre><code>var thisp = {};
scheduled.register(&quot;thisp&quot;, function() {
	assert.strictEqual(this, thisp);
}, 0, thisp);
scheduled.next()();</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Skill</h1>
      <dl>
        <section class="suite">
          <h1>.createSkill</h1>
          <dl>
            <dt>should create a Skill constructor</dt>
            <dd><pre><code>assert.strictEqual(Skill.prototype.isPrototypeOf(Bootshine), true);</code></pre></dd>
            <section class="suite">
              <h1>#_onUse</h1>
              <dl>
                <dt>should trigger #onUse</dt>
                <dd><pre><code>assert(called);</code></pre></dd>
                <dt>should make skill unavailable</dt>
                <dd><pre><code>assert.strictEqual(HowlingFist.isAvailable(time), false);</code></pre></dd>
              </dl>
            </section>
            <section class="suite">
              <h1>#isAvailable</h1>
              <dl>
                <dt>should return false if the skill is recharging</dt>
                <dd><pre><code>HowlingFist._onUse(time);
assert.strictEqual(HowlingFist.isAvailable(time), false);</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Stats.ccbrown</h1>
      <dl>
        <section class="suite">
          <h1>#getSkillDamage</h1>
          <dl>
            <dt>should return 192.95 for 100 potency</dt>
            <dd><pre><code>assert.strictEqual(stats.getSkillDamage(100).toFixed(2), &quot;192.95&quot;);</code></pre></dd>
            <dt>should return 220.22 for 100 potency with 30% crit bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 0.3}).getSkillDamage(100).toFixed(2), &quot;220.22&quot;);</code></pre></dd>
            <dt>should return 242.24 for 100 potency with 30% crit bonus and 10% damage bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 0.3, increaseDamage: 1.1}).getSkillDamage(100).toFixed(2), &quot;242.24&quot;);</code></pre></dd>
            <dt>should return 212.24 for 100 potency with 10% damage bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({increaseDamage: 1.1}).getSkillDamage(100).toFixed(2), &quot;212.24&quot;);</code></pre></dd>
            <dt>should return 272.66 for 100 potency with 100% crit bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 1}).getSkillDamage(100).toFixed(2), &quot;272.66&quot;);
assert.strictEqual(stats.buff({criticalHitChance: 2}).getSkillDamage(100).toFixed(2), &quot;272.66&quot;);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getAutoAttackDamage</h1>
          <dl>
            <dt>should return 163.79</dt>
            <dd><pre><code>assert.strictEqual(stats.getAutoAttackDamage().toFixed(2), &quot;163.79&quot;);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Stats</h1>
      <dl>
        <section class="suite">
          <h1>#buff</h1>
          <dl>
            <dt>should return a new Object</dt>
            <dd><pre><code>assert.notStrictEqual(stats, stats.buff());</code></pre></dd>
            <dt>should have the same base stats</dt>
            <dd><pre><code>assert.deepEqual(stats, stats.buff(), &quot;\n&quot; + util.format(&quot;%j&quot;, stats) + &quot;\n&quot; + util.format(&quot;%j&quot;, stats.buff()));</code></pre></dd>
            <dt>should buff values with the provided multiplier</dt>
            <dd><pre><code>var buff = stats.buff({
	strength:1.1,
	determination:1.1
})
assert.strictEqual(stats.strength*1.1, buff.strength);
assert.strictEqual(stats.determination*1.1, buff.determination);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getCriticalRate</h1>
          <dl>
            <dt>should return 0.12</dt>
            <dd><pre><code>assert.strictEqual(stats.getCriticalRate().toFixed(2), &quot;0.12&quot;);</code></pre></dd>
            <dt>should return 0.42 with 30% crit bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 0.3}).getCriticalRate().toFixed(2), &quot;0.42&quot;);</code></pre></dd>
            <dt>should not exceed 1</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 1}).getCriticalRate().toFixed(2), &quot;1.00&quot;);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getGCD</h1>
          <dl>
            <dt>should return 2.44</dt>
            <dd><pre><code>assert.strictEqual(stats.getGCD().toFixed(2), &quot;2.44&quot;);</code></pre></dd>
            <dt>should return 2.07 with 0.15 speed bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({reducedGlobalCooldown: 0.15}).getGCD().toFixed(2), &quot;2.07&quot;);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getAutoAttackDelay</h1>
          <dl>
            <dt>should return 2.40</dt>
            <dd><pre><code>assert.strictEqual(stats.getAutoAttackDelay().toFixed(2), &quot;2.40&quot;);</code></pre></dd>
            <dt>should return 2.04 with 0.15 speed bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({increasedAutoAttackSpeed: 0.15}).getAutoAttackDelay().toFixed(2), &quot;2.04&quot;);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Stats.valkky</h1>
      <dl>
        <section class="suite">
          <h1>#getSkillDamage</h1>
          <dl>
            <dt>should return 185.30 for 100 potency</dt>
            <dd><pre><code>assert.strictEqual(stats.getSkillDamage(100).toFixed(2), &quot;185.30&quot;);</code></pre></dd>
            <dt>should return 211.49 for 100 potency with 30% crit bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 0.3}).getSkillDamage(100).toFixed(2), &quot;211.49&quot;);</code></pre></dd>
            <dt>should return 232.64 for 100 potency with 30% crit bonus and 10% damage bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 0.3, increaseDamage: 1.1}).getSkillDamage(100).toFixed(2), &quot;232.64&quot;);</code></pre></dd>
            <dt>should return 203.83 for 100 potency with 10% damage bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({increaseDamage: 1.1}).getSkillDamage(100).toFixed(2), &quot;203.83&quot;);</code></pre></dd>
            <dt>should return 261.85 for 100 potency with 100% crit bonus</dt>
            <dd><pre><code>assert.strictEqual(stats.buff({criticalHitChance: 1}).getSkillDamage(100).toFixed(2), &quot;261.85&quot;);
assert.strictEqual(stats.buff({criticalHitChance: 2}).getSkillDamage(100).toFixed(2), &quot;261.85&quot;);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#getAutoAttackDamage</h1>
          <dl>
            <dt>should return 158.75</dt>
            <dd><pre><code>assert.strictEqual(stats.getAutoAttackDamage().toFixed(2), &quot;158.75&quot;);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
